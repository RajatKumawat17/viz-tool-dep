<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Automated Data Visualization Tool</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.18.2/plotly.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.4.2/mammoth.browser.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }
        
        .upload-section {
            padding: 40px;
            text-align: center;
            border-bottom: 1px solid #eee;
        }
        
        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 60px 20px;
            transition: all 0.3s ease;
            cursor: pointer;
            background: #f8f9ff;
        }
        
        .upload-area:hover {
            border-color: #764ba2;
            background: #f0f2ff;
            transform: translateY(-2px);
        }
        
        .upload-area.dragover {
            border-color: #764ba2;
            background: #e8ebff;
        }
        
        .upload-icon {
            font-size: 4em;
            color: #667eea;
            margin-bottom: 20px;
        }
        
        .upload-text {
            font-size: 1.2em;
            margin-bottom: 10px;
            color: #333;
        }
        
        .upload-subtext {
            color: #666;
            font-size: 0.9em;
        }
        
        .file-input {
            display: none;
        }
        
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 30px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
            margin: 10px;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .progress-section {
            padding: 20px 40px;
            display: none;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #eee;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .status-text {
            text-align: center;
            color: #666;
            margin: 10px 0;
        }
        
        .results-section {
            padding: 40px;
            display: none;
        }
        
        .insights-panel {
            background: #f8f9ff;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
        }
        
        .insights-panel h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        
        .insight-item {
            background: white;
            padding: 12px 15px;
            margin: 8px 0;
            border-radius: 8px;
            border-left: 4px solid #667eea;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        
        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 30px;
            margin-top: 30px;
        }
        
        .chart-container {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
            border: 1px solid #eee;
        }
        
        .chart-title {
            font-size: 1.2em;
            margin-bottom: 15px;
            color: #333;
            text-align: center;
        }
        
        .download-section {
            text-align: center;
            margin-top: 30px;
            padding-top: 30px;
            border-top: 1px solid #eee;
        }
        
        .error-message {
            background: #ffe6e6;
            color: #d32f2f;
            padding: 15px;
            border-radius: 8px;
            margin: 20px;
            display: none;
        }
        
        .success-message {
            background: #e8f5e9;
            color: #2e7d32;
            padding: 15px;
            border-radius: 8px;
            margin: 20px;
            display: none;
        }
        
        @media (max-width: 768px) {
            .charts-grid {
                grid-template-columns: 1fr;
            }
            
            .container {
                margin: 10px;
                border-radius: 15px;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .upload-section, .results-section {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸ¤– Automated Data Visualization</h1>
            <p>Upload your CSV or Excel file and get instant insights with beautiful visualizations</p>
        </div>
        
        <div class="upload-section">
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">ðŸ“Š</div>
                <div class="upload-text">Drop your file here or click to browse</div>
                <div class="upload-subtext">Supports CSV, Excel (.xlsx, .xls) files</div>
            </div>
            <input type="file" id="fileInput" class="file-input" accept=".csv,.xlsx,.xls">
            <button class="btn" onclick="document.getElementById('fileInput').click()">Choose File</button>
        </div>
        
        <div class="progress-section" id="progressSection">
            <div class="status-text" id="statusText">Processing your data...</div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>
        
        <div class="error-message" id="errorMessage"></div>
        <div class="success-message" id="successMessage"></div>
        
        <div class="results-section" id="resultsSection">
            <div class="insights-panel">
                <h3>ðŸ“‹ Key Insights</h3>
                <div id="insightsContainer"></div>
            </div>
            
            <div class="charts-grid" id="chartsContainer"></div>
            
            <div class="download-section">
                <button class="btn" id="downloadBtn" onclick="downloadReport()">
                    ðŸ“„ Download Complete Report
                </button>
            </div>
        </div>
    </div>

    <script>
        let processedData = null;
        let generatedCharts = [];
        let dataInsights = [];

        // File upload handling
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        
        uploadArea.addEventListener('click', () => fileInput.click());
        uploadArea.addEventListener('dragover', handleDragOver);
        uploadArea.addEventListener('dragleave', handleDragLeave);
        uploadArea.addEventListener('drop', handleDrop);
        fileInput.addEventListener('change', handleFileSelect);

        function handleDragOver(e) {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        }

        function handleDragLeave(e) {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
        }

        function handleDrop(e) {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                processFile(files[0]);
            }
        }

        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file) {
                processFile(file);
            }
        }

        function showProgress(message = "Processing...") {
            document.getElementById('progressSection').style.display = 'block';
            document.getElementById('statusText').textContent = message;
            document.getElementById('resultsSection').style.display = 'none';
            hideMessages();
        }

        function updateProgress(percentage) {
            document.getElementById('progressFill').style.width = percentage + '%';
        }

        function hideProgress() {
            document.getElementById('progressSection').style.display = 'none';
        }

        function showError(message) {
            const errorEl = document.getElementById('errorMessage');
            errorEl.textContent = message;
            errorEl.style.display = 'block';
            hideProgress();
        }

        function showSuccess(message) {
            const successEl = document.getElementById('successMessage');
            successEl.textContent = message;
            successEl.style.display = 'block';
        }

        function hideMessages() {
            document.getElementById('errorMessage').style.display = 'none';
            document.getElementById('successMessage').style.display = 'none';
        }

        async function processFile(file) {
            try {
                showProgress("Reading file...");
                updateProgress(10);

                const fileExtension = file.name.split('.').pop().toLowerCase();
                let data;

                if (fileExtension === 'csv') {
                    data = await parseCSV(file);
                } else if (['xlsx', 'xls'].includes(fileExtension)) {
                    data = await parseExcel(file);
                } else {
                    throw new Error('Unsupported file format. Please use CSV or Excel files.');
                }

                updateProgress(30);
                showProgress("Analyzing data structure...");

                processedData = data;
                await analyzeAndVisualize();

            } catch (error) {
                showError('Error processing file: ' + error.message);
            }
        }

        function parseCSV(file) {
            return new Promise((resolve, reject) => {
                Papa.parse(file, {
                    header: true,
                    dynamicTyping: true,
                    skipEmptyLines: true,
                    complete: (results) => {
                        if (results.errors.length > 0) {
                            reject(new Error('CSV parsing error: ' + results.errors[0].message));
                        } else {
                            resolve(results.data);
                        }
                    },
                    error: (error) => reject(error)
                });
            });
        }

        async function parseExcel(file) {
            // For Excel files, we'll use a simple approach
            // In a real implementation, you'd want to use a proper Excel parser
            throw new Error('Excel support requires additional setup. Please use CSV files for now.');
        }

        async function analyzeAndVisualize() {
            try {
                updateProgress(40);
                showProgress("Generating insights...");

                // Generate insights
                dataInsights = generateInsights(processedData);
                displayInsights(dataInsights);

                updateProgress(60);
                showProgress("Creating visualizations...");

                // Generate charts
                await createAllCharts();

                updateProgress(100);
                hideProgress();
                
                document.getElementById('resultsSection').style.display = 'block';
                showSuccess('Analysis complete! Your visualizations are ready.');

            } catch (error) {
                showError('Error during analysis: ' + error.message);
            }
        }

        function generateInsights(data) {
            const insights = [];
            const columns = Object.keys(data[0] || {});
            const numericColumns = columns.filter(col => 
                data.some(row => typeof row[col] === 'number' && !isNaN(row[col]))
            );
            const categoricalColumns = columns.filter(col => 
                !numericColumns.includes(col)
            );

            insights.push(`Dataset contains ${data.length.toLocaleString()} rows and ${columns.length} columns`);
            insights.push(`Data types: ${numericColumns.length} numeric, ${categoricalColumns.length} categorical`);

            // Missing data analysis
            const missingData = {};
            columns.forEach(col => {
                const missing = data.filter(row => row[col] == null || row[col] === '').length;
                if (missing > 0) {
                    missingData[col] = missing;
                }
            });

            if (Object.keys(missingData).length > 0) {
                insights.push(`Missing data found in ${Object.keys(missingData).length} columns`);
            }

            // Numeric insights
            numericColumns.slice(0, 3).forEach(col => {
                const values = data.map(row => row[col]).filter(val => val != null && !isNaN(val));
                if (values.length > 0) {
                    const mean = values.reduce((a, b) => a + b, 0) / values.length;
                    const sorted = values.sort((a, b) => a - b);
                    const median = sorted[Math.floor(sorted.length / 2)];
                    insights.push(`${col}: mean=${mean.toFixed(2)}, median=${median.toFixed(2)}`);
                }
            });

            // Categorical insights
            categoricalColumns.slice(0, 3).forEach(col => {
                const unique = new Set(data.map(row => row[col]).filter(val => val != null)).size;
                insights.push(`${col}: ${unique} unique values`);
            });

            return insights;
        }

        function displayInsights(insights) {
            const container = document.getElementById('insightsContainer');
            container.innerHTML = '';
            
            insights.forEach(insight => {
                const div = document.createElement('div');
                div.className = 'insight-item';
                div.textContent = insight;
                container.appendChild(div);
            });
        }

        async function createAllCharts() {
            const container = document.getElementById('chartsContainer');
            container.innerHTML = '';
            generatedCharts = [];

            const columns = Object.keys(processedData[0] || {});
            const numericColumns = columns.filter(col => 
                processedData.some(row => typeof row[col] === 'number' && !isNaN(row[col]))
            );
            const categoricalColumns = columns.filter(col => 
                !numericColumns.includes(col)
            );

            // Create distribution charts for numeric columns
            for (let i = 0; i < Math.min(numericColumns.length, 4); i++) {
                const col = numericColumns[i];
                await createDistributionChart(col, container);
            }

            // Create categorical charts
            for (let i = 0; i < Math.min(categoricalColumns.length, 3); i++) {
                const col = categoricalColumns[i];
                await createCategoricalChart(col, container);
            }

            // Create correlation chart if we have enough numeric columns
            if (numericColumns.length >= 2) {
                await createCorrelationChart(numericColumns.slice(0, 4), container);
            }

            // Create scatter plot for top 2 numeric columns
            if (numericColumns.length >= 2) {
                await createScatterChart(numericColumns[0], numericColumns[1], container);
            }
        }

        function createDistributionChart(column, container) {
            return new Promise((resolve) => {
                const chartDiv = document.createElement('div');
                chartDiv.className = 'chart-container';
                chartDiv.innerHTML = `
                    <div class="chart-title">Distribution of ${column}</div>
                    <canvas id="dist_${column.replace(/\s+/g, '_')}" width="400" height="300"></canvas>
                `;
                container.appendChild(chartDiv);

                const canvas = chartDiv.querySelector('canvas');
                const ctx = canvas.getContext('2d');

                // Get values and create histogram
                const values = processedData
                    .map(row => row[column])
                    .filter(val => val != null && !isNaN(val))
                    .sort((a, b) => a - b);

                if (values.length === 0) {
                    resolve();
                    return;
                }

                // Create bins
                const min = Math.min(...values);
                const max = Math.max(...values);
                const binCount = Math.min(20, Math.sqrt(values.length));
                const binSize = (max - min) / binCount;
                
                const bins = Array(Math.ceil(binCount)).fill(0);
                const labels = [];
                
                for (let i = 0; i < bins.length; i++) {
                    labels.push((min + i * binSize).toFixed(2));
                }

                values.forEach(value => {
                    const binIndex = Math.min(Math.floor((value - min) / binSize), bins.length - 1);
                    bins[binIndex]++;
                });

                new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Frequency',
                            data: bins,
                            backgroundColor: 'rgba(102, 126, 234, 0.6)',
                            borderColor: 'rgba(102, 126, 234, 1)',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: {
                                display: false
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Frequency'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: column
                                }
                            }
                        }
                    }
                });

                generatedCharts.push({
                    type: 'distribution',
                    column: column,
                    description: `Distribution of ${column}`
                });

                resolve();
            });
        }

        function createCategoricalChart(column, container) {
            return new Promise((resolve) => {
                const chartDiv = document.createElement('div');
                chartDiv.className = 'chart-container';
                chartDiv.innerHTML = `
                    <div class="chart-title">Distribution of ${column}</div>
                    <canvas id="cat_${column.replace(/\s+/g, '_')}" width="400" height="300"></canvas>
                `;
                container.appendChild(chartDiv);

                const canvas = chartDiv.querySelector('canvas');
                const ctx = canvas.getContext('2d');

                // Count occurrences
                const counts = {};
                processedData.forEach(row => {
                    const value = row[column];
                    if (value != null && value !== '') {
                        counts[value] = (counts[value] || 0) + 1;
                    }
                });

                // Get top 10 categories
                const sortedEntries = Object.entries(counts)
                    .sort(([,a], [,b]) => b - a)
                    .slice(0, 10);

                const labels = sortedEntries.map(([label]) => label);
                const data = sortedEntries.map(([,count]) => count);

                new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Count',
                            data: data,
                            backgroundColor: 'rgba(118, 75, 162, 0.6)',
                            borderColor: 'rgba(118, 75, 162, 1)',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: {
                                display: false
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Count'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: column
                                }
                            }
                        }
                    }
                });

                generatedCharts.push({
                    type: 'categorical',
                    column: column,
                    description: `Category distribution of ${column}`
                });

                resolve();
            });
        }

        function createScatterChart(xColumn, yColumn, container) {
            return new Promise((resolve) => {
                const chartDiv = document.createElement('div');
                chartDiv.className = 'chart-container';
                chartDiv.innerHTML = `
                    <div class="chart-title">${xColumn} vs ${yColumn}</div>
                    <canvas id="scatter_${xColumn}_${yColumn}".replace(/\s+/g, '_') width="400" height="300"></canvas>
                `;
                container.appendChild(chartDiv);

                const canvas = chartDiv.querySelector('canvas');
                const ctx = canvas.getContext('2d');

                // Prepare scatter data
                const scatterData = processedData
                    .filter(row => row[xColumn] != null && row[yColumn] != null && 
                                  !isNaN(row[xColumn]) && !isNaN(row[yColumn]))
                    .map(row => ({
                        x: row[xColumn],
                        y: row[yColumn]
                    }));

                new Chart(ctx, {
                    type: 'scatter',
                    data: {
                        datasets: [{
                            label: `${xColumn} vs ${yColumn}`,
                            data: scatterData,
                            backgroundColor: 'rgba(102, 126, 234, 0.6)',
                            borderColor: 'rgba(102, 126, 234, 1)',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: {
                                display: false
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: xColumn
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: yColumn
                                }
                            }
                        }
                    }
                });

                generatedCharts.push({
                    type: 'scatter',
                    columns: [xColumn, yColumn],
                    description: `Scatter plot: ${xColumn} vs ${yColumn}`
                });

                resolve();
            });
        }

        function createCorrelationChart(columns, container) {
            return new Promise((resolve) => {
                // Simple correlation visualization using a table
                const chartDiv = document.createElement('div');
                chartDiv.className = 'chart-container';
                chartDiv.innerHTML = `
                    <div class="chart-title">Correlation Matrix</div>
                    <div id="correlation_table"></div>
                `;
                container.appendChild(chartDiv);

                // Calculate correlations
                const correlations = {};
                for (let i = 0; i < columns.length; i++) {
                    correlations[columns[i]] = {};
                    for (let j = 0; j < columns.length; j++) {
                        if (i === j) {
                            correlations[columns[i]][columns[j]] = 1;
                        } else {
                            const corr = calculateCorrelation(columns[i], columns[j]);
                            correlations[columns[i]][columns[j]] = corr;
                        }
                    }
                }

                // Create table
                let tableHTML = '<table style="width:100%; border-collapse: collapse;">';
                tableHTML += '<tr><th style="border:1px solid #ddd; padding:8px;"></th>';
                columns.forEach(col => {
                    tableHTML += `<th style="border:1px solid #ddd; padding:8px; font-size:0.9em;">${col}</th>`;
                });
                tableHTML += '</tr>';

                columns.forEach(rowCol => {
                    tableHTML += `<tr><th style="border:1px solid #ddd; padding:8px; font-size:0.9em;">${rowCol}</th>`;
                    columns.forEach(colCol => {
                        const corr = correlations[rowCol][colCol];
                        const intensity = Math.abs(corr);
                        const color = corr > 0 ? `rgba(102, 126, 234, ${intensity})` : `rgba(244, 67, 54, ${intensity})`;
                        tableHTML += `<td style="border:1px solid #ddd; padding:8px; background:${color}; text-align:center; font-size:0.8em;">${corr.toFixed(2)}</td>`;
                    });
                    tableHTML += '</tr>';
                });
                tableHTML += '</table>';

                document.getElementById('correlation_table').innerHTML = tableHTML;

                generatedCharts.push({
                    type: 'correlation',
                    columns: columns,
                    description: 'Correlation matrix of numeric variables'
                });

                resolve();
            });
        }

        function calculateCorrelation(col1, col2) {
            const pairs = processedData
                .filter(row => row[col1] != null && row[col2] != null && 
                              !isNaN(row[col1]) && !isNaN(row[col2]))
                .map(row => [row[col1], row[col2]]);

            if (pairs.length < 2) return 0;

            const n = pairs.length;
            const sum1 = pairs.reduce((sum, [x]) => sum + x, 0);
            const sum2 = pairs.reduce((sum, [, y]) => sum + y, 0);
            const sum1Sq = pairs.reduce((sum, [x]) => sum + x * x, 0);
            const sum2Sq = pairs.reduce((sum, [, y]) => sum + y * y, 0);
            const pSum = pairs.reduce((sum, [x, y]) => sum + x * y, 0);

            const num = pSum - (sum1 * sum2 / n);
            const den = Math.sqrt((sum1Sq - sum1 * sum1 / n) * (sum2Sq - sum2 * sum2 / n));

            return den === 0 ? 0 : num / den;
        }

        function downloadReport() {
            const reportHTML = generateHTMLReport();
            const blob = new Blob([reportHTML], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `data_analysis_report_${new Date().toISOString().split('T')[0]}.html`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function generateHTMLReport() {
            const timestamp = new Date().toLocaleString();
            
            let chartsHTML = '';
            generatedCharts.forEach((chart, index) => {
                chartsHTML += `
                    <div class="chart-section">
                        <h3>${chart.description}</h3>
                        <p><strong>Type:</strong> ${chart.type}</p>
                        <p><strong>Columns:</strong> ${Array.isArray(chart.columns) ? chart.columns.join(', ') : chart.column || 'N/A'}</p>
                        <p><em>Chart visualization was generated in the web application</em></p>
                    </div>
                `;
            });

            let insightsHTML = '';
            dataInsights.forEach(insight => {
                insightsHTML += `<div class="insight">â€¢ ${insight}</div>`;
            });

            return `
<!DOCTYPE html>
<html>
<head>
    <title>Automated Data Analysis Report</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; }
        .header { background: #f4f4f4; padding: 20px; border-radius: 5px; margin-bottom: 30px; }
        .insight { background: #e8f5e9; padding: 10px; margin: 10px 0; border-radius: 3px; }
        .chart-section { margin: 30px 0; padding: 20px; border: 1px solid #ddd; border-radius: 5px; }
        .timestamp { color: #666; font-size: 0.9em; }
        .summary { background: #f0f8ff; padding: 20px; border-radius: 5px; margin-top: 30px; }
    </style>
</head>
<body>
    <div class="header">
        <h1>ðŸ¤– Automated Data Analysis Report</h1>
        <p class="timestamp">Generated on: ${timestamp}</p>
    </div>
    
    <h2>ðŸ“‹ Key Insights</h2>
    ${insightsHTML}
    
    <h2>ðŸ“Š Generated Visualizations</h2>
    ${chartsHTML}
    
    <div class="summary">
        <h3>ðŸŽ¯ Summary</h3>
        <p>This automated analysis identified key patterns in your data and generated ${generatedCharts.length} visualizations. 
        The charts were created using advanced statistical analysis to highlight distributions, correlations, and categorical patterns in your dataset.</p>
        <p><strong>Total Records:</strong> ${processedData.length.toLocaleString()}</p>
        <p><strong>Analysis Date:</strong> ${timestamp}</p>
    </div>
</body>
</html>
            `;
        }
    </script>
</body>
</html>